#!/usr/bin/env node
'use strict';

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _url = require('url');

var _string_decoder = require('string_decoder');

var _micro = require('micro');

var _micro2 = _interopRequireDefault(_micro);

var _chalk = require('chalk');

var _args = require('args');

var _args2 = _interopRequireDefault(_args);

var _handlebars = require('handlebars');

var _istextorbinary = require('istextorbinary');

var _filesize = require('filesize');

var _filesize2 = _interopRequireDefault(_filesize);

var _mimeTypes = require('mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

var _microCompress = require('micro-compress');

var _microCompress2 = _interopRequireDefault(_microCompress);

var _fsPromise = require('fs-promise');

var _fsPromise2 = _interopRequireDefault(_fsPromise);

var _basicAuth = require('basic-auth');

var _basicAuth2 = _interopRequireDefault(_basicAuth);

var _send = require('send');

var _send2 = _interopRequireDefault(_send);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Native


// Packages


_args2.default.option('port', 'Port to listen on', process.env.PORT || 3000).option('cache', 'How long static files should be cached in the browser (seconds)', 3600).option('single', 'Serve single page apps with only one index.html').option('unzipped', 'Disable GZIP compression').option('ignore', 'Files and directories to ignore', '').option('auth', 'Serve behind basic auth');

const flags = _args2.default.parse(process.argv);
const directory = _args2.default.sub[0];

process.env.ASSET_DIR = '/' + Math.random().toString(36).substr(2, 10);

let current = process.cwd();

if (directory) {
  current = _path2.default.resolve(process.cwd(), directory);
}

const isDir = (() => {
  var _ref = _asyncToGenerator(function* (dir) {
    let stats;

    try {
      stats = yield _fsPromise2.default.stat(dir);
    } catch (err) {
      return false;
    }

    if (stats.isDirectory()) {
      return true;
    }

    return false;
  });

  return function isDir(_x) {
    return _ref.apply(this, arguments);
  };
})();

const prepareView = () => {
  let viewContent = false;
  const viewPath = _path2.default.normalize(_path2.default.join(__dirname, '/../../views/index.hbs'));

  try {
    viewContent = _fsPromise2.default.readFileSync(viewPath, 'utf8');
  } catch (err) {
    throw err;
  }

  return (0, _handlebars.compile)(viewContent);
};

let ignoredFiles = ['.DS_Store', '.git/'];

if (flags.ignore && flags.ignore.length) {
  ignoredFiles = ignoredFiles.concat(flags.ignore.split(','));
}

const renderDirectory = (() => {
  var _ref2 = _asyncToGenerator(function* (dir) {
    let files = [];
    const subPath = _path2.default.relative(current, dir);

    if (!_fsPromise2.default.existsSync(dir)) {
      return false;
    }

    try {
      files = yield _fsPromise2.default.readdir(dir);
    } catch (err) {
      throw err;
    }

    for (const file of files) {
      const filePath = _path2.default.resolve(dir, file);
      const index = files.indexOf(file);
      const details = _path2.default.parse(filePath);

      details.relative = _path2.default.join(subPath, details.base);

      if (yield isDir(filePath)) {
        details.base += '/';
      } else {
        details.ext = details.ext.split('.')[1] || 'txt';

        let fileStats;

        try {
          fileStats = yield _fsPromise2.default.stat(filePath);
        } catch (err) {
          throw err;
        }

        details.size = (0, _filesize2.default)(fileStats.size, { round: 0 });
      }

      if (ignoredFiles.indexOf(details.base) > -1) {
        delete files[index];
      } else {
        files[files.indexOf(file)] = details;
      }
    }

    const directory = _path2.default.join(_path2.default.basename(current), subPath, '/');
    const pathParts = directory.split('/');

    if (dir.indexOf(current + '/') > -1) {
      const directoryPath = [...pathParts];
      directoryPath.shift();

      files.unshift({
        base: '..',
        relative: _path2.default.join(...directoryPath, '..')
      });
    }

    const render = prepareView();

    const paths = [];
    pathParts.pop();

    for (const part in pathParts) {
      if (!{}.hasOwnProperty.call(pathParts, part)) {
        continue;
      }

      let before = 0;
      const parents = [];

      while (before <= part) {
        parents.push(pathParts[before]);
        before++;
      }

      parents.shift();

      paths.push({
        name: pathParts[part],
        url: parents.join('/')
      });
    }

    const details = {
      port: flags.port,
      files,
      assetDir: process.env.ASSET_DIR,
      directory,
      nodeVersion: process.version.split('v')[1],
      paths
    };

    return render(details);
  });

  return function renderDirectory(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

const handler = (() => {
  var _ref3 = _asyncToGenerator(function* (req, res) {
    if (flags.auth) {
      const credentials = (0, _basicAuth2.default)(req);

      if (!process.env.SERVE_USER || !process.env.SERVE_PASSWORD) {
        console.error((0, _chalk.red)('You are running serve with basic auth but did not set the SERVE_USER and SERVE_PASSWORD environment variables.'));
        process.exit(1);
      }

      if (!credentials || credentials.name !== process.env.SERVE_USER || credentials.pass !== process.env.SERVE_PASSWORD) {
        res.statusCode = 401;
        res.setHeader('WWW-Authenticate', 'Basic realm="User Visible Realm"');
        return (0, _micro.send)(res, 401, 'Access Denied');
      }
    }

    const { pathname } = (0, _url.parse)(req.url);
    let related = _path2.default.parse(_path2.default.join(current, pathname));

    if (related.dir.indexOf(process.env.ASSET_DIR) > -1) {
      const relative = _path2.default.relative(process.env.ASSET_DIR, pathname);
      related = _path2.default.parse(_path2.default.join(__dirname, '/../assets', relative));
    }

    related = decodeURIComponent(_path2.default.format(related));

    let notFoundResponse = 'Not Found';

    try {
      const custom404Path = _path2.default.join(current, '/404.html');
      notFoundResponse = yield _fsPromise2.default.readFile(custom404Path, 'utf-8');
    } catch (err) {}

    if (!_fsPromise2.default.existsSync(related) && flags.single === undefined) {
      return (0, _micro.send)(res, 404, notFoundResponse);
    }

    // Check if file or directory path
    if (yield isDir(related)) {
      let indexPath = _path2.default.join(related, '/index.html');

      res.setHeader('Content-Type', _mimeTypes2.default.contentType(_path2.default.extname(indexPath)));

      if (!_fsPromise2.default.existsSync(indexPath)) {
        // Try to render the current directory's content
        const renderedDir = yield renderDirectory(related);

        // If it works, send the directory listing to the user
        if (renderedDir) {
          return (0, _micro.send)(res, 200, renderedDir);
        }

        // And if it doesn't, see if it's a single page application
        // If that's not true either, send an error
        if (!flags.single) {
          return (0, _micro.send)(res, 404, notFoundResponse);
        }

        // But IF IT IS true, load the SPA's root index file
        indexPath = _path2.default.join(current, '/index.html');
      }

      let indexContent;

      try {
        indexContent = yield _fsPromise2.default.readFile(indexPath, 'utf8');
      } catch (err) {
        throw err;
      }

      return (0, _micro.send)(res, 200, indexContent);
    }

    if (!_fsPromise2.default.existsSync(related) && flags.single) {
      const indexPath = _path2.default.join(current, '/index.html');
      let indexContent;

      try {
        indexContent = yield _fsPromise2.default.readFile(indexPath, 'utf8');
      } catch (err) {
        return (0, _micro.send)(res, 404, notFoundResponse);
      }

      return (0, _micro.send)(res, 200, indexContent);
    }

    let body = 'Not able to load file!';
    let stats;

    try {
      body = yield _fsPromise2.default.readFile(related);
      stats = yield _fsPromise2.default.stat(related);
    } catch (err) {
      if (err instanceof RangeError) {
        return (0, _send2.default)(req, related).pipe(res);
      }

      throw err;
    }

    const binaryStat = (0, _istextorbinary.isBinarySync)(_path2.default.parse(related).base, body);
    const getETag = function (s) {
      return '"' + s.dev + '-' + s.ino + '-' + s.mtime.getTime() + '"';
    };

    let requestDate = req.headers['if-modified-since'];
    let statusCode = 200;

    if (requestDate) {
      requestDate = new Date(requestDate);

      if (requestDate.getTime() === stats.mtime.getTime()) {
        statusCode = 304;
      }
    }

    const defaultHeaders = {
      'Cache-Control': 'public, max-age=' + flags.cache,
      Pragma: 'public',
      ETag: getETag(stats)
    };

    for (const header in defaultHeaders) {
      if (!{}.hasOwnProperty.call(defaultHeaders, header)) {
        continue;
      }

      res.setHeader(header, defaultHeaders[header]);
    }

    if (binaryStat) {
      res.statusCode = statusCode;
      res.end(body, 'binary');
    } else {
      const decoder = new _string_decoder.StringDecoder('utf8');
      const contentType = _mimeTypes2.default.contentType(_path2.default.extname(related)) || _mimeTypes2.default.contentType('text');

      res.setHeader('Content-Type', contentType);
      (0, _micro.send)(res, statusCode, decoder.write(body));
    }
  });

  return function handler(_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
})();

const server = flags.unzipped ? (0, _micro2.default)(handler) : (0, _micro2.default)((0, _microCompress2.default)(handler));

server.listen(flags.port, _asyncToGenerator(function* () {
  const details = server.address();

  process.on('SIGINT', function () {
    server.close();
    process.exit(0);
  });

  if (!(yield isDir(current))) {
    console.error((0, _chalk.red)('Specified directory doesn\'t exist!'));
    process.exit(1);
  }

  if (!process.env.NOW) {
    console.log((0, _chalk.green)(`Running on http://localhost:${ details.port }`));
  }
}));